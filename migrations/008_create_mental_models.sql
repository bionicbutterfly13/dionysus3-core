-- Migration: 008_create_mental_models
-- Feature: 005-mental-models
-- Tasks: T001-T010 (Phase 1: Setup)
--
-- Creates mental model tables, indexes, views, and functions
-- Based on Yufik's neuronal packet theory (2019, 2021)

-- ============================================================================
-- ENUMS
-- ============================================================================

-- Model domain types
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'model_domain') THEN
        CREATE TYPE model_domain AS ENUM ('user', 'self', 'world', 'task_specific');
    END IF;
END $$;

-- Model status lifecycle
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'model_status') THEN
        CREATE TYPE model_status AS ENUM ('draft', 'active', 'deprecated');
    END IF;
END $$;

-- Revision trigger types
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'revision_trigger') THEN
        CREATE TYPE revision_trigger AS ENUM ('prediction_error', 'new_evidence', 'contradiction', 'manual');
    END IF;
END $$;

-- ============================================================================
-- T001: TABLES
-- ============================================================================

-- Mental Models: Structured combinations of memory basins that generate predictions
CREATE TABLE IF NOT EXISTS mental_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    domain model_domain NOT NULL,
    description TEXT,

    -- Basin composition (references memory_clusters)
    constituent_basins UUID[] NOT NULL CHECK (array_length(constituent_basins, 1) >= 1),
    basin_relationships JSONB DEFAULT '{"relationships": []}',

    -- Prediction capabilities
    prediction_templates JSONB[] DEFAULT ARRAY[]::JSONB[],
    explanatory_scope TEXT[] DEFAULT ARRAY[]::TEXT[],
    requires_sensory_input BOOLEAN DEFAULT FALSE,
    temporal_horizon INTERVAL,

    -- Evidence and validation
    evidence_memories UUID[] DEFAULT ARRAY[]::UUID[],
    prediction_accuracy FLOAT DEFAULT 0.5 CHECK (prediction_accuracy >= 0.0 AND prediction_accuracy <= 1.0),
    last_validated TIMESTAMPTZ,

    -- Lifecycle
    revision_count INTEGER DEFAULT 0,
    status model_status DEFAULT 'draft',
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    -- Ensure unique names
    CONSTRAINT mental_models_name_unique UNIQUE (name)
);

-- Model Predictions: Specific predictions generated by models
CREATE TABLE IF NOT EXISTS model_predictions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES mental_models(id) ON DELETE CASCADE,

    -- Prediction content
    prediction JSONB NOT NULL,
    confidence FLOAT DEFAULT 0.5 CHECK (confidence >= 0.0 AND confidence <= 1.0),
    context JSONB,

    -- Resolution (filled when prediction is resolved)
    observation JSONB,
    prediction_error FLOAT CHECK (prediction_error IS NULL OR (prediction_error >= 0.0 AND prediction_error <= 1.0)),
    resolved_at TIMESTAMPTZ,

    -- Link to active inference state
    inference_state_id UUID,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    -- If resolved, must have observation and error
    CONSTRAINT prediction_resolution_complete CHECK (
        (resolved_at IS NULL) OR
        (resolved_at IS NOT NULL AND observation IS NOT NULL AND prediction_error IS NOT NULL)
    )
);

-- Model Revisions: Historical record of changes to model structure
CREATE TABLE IF NOT EXISTS model_revisions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES mental_models(id) ON DELETE CASCADE,

    -- Trigger information
    trigger_type revision_trigger NOT NULL,
    trigger_memory_id UUID,
    trigger_description TEXT,

    -- Structure changes
    old_structure JSONB,
    new_structure JSONB,
    basins_added UUID[] DEFAULT ARRAY[]::UUID[],
    basins_removed UUID[] DEFAULT ARRAY[]::UUID[],
    change_description TEXT,

    -- Accuracy tracking
    prediction_error_before FLOAT,
    prediction_error_after FLOAT,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- ============================================================================
-- T002-T004: INDEXES
-- ============================================================================

-- T002: Indexes for mental_models
CREATE INDEX IF NOT EXISTS idx_mental_models_domain ON mental_models(domain);
CREATE INDEX IF NOT EXISTS idx_mental_models_status ON mental_models(status) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_mental_models_constituent_basins ON mental_models USING GIN(constituent_basins);
CREATE INDEX IF NOT EXISTS idx_mental_models_created_at ON mental_models(created_at);

-- T003: Indexes for model_predictions
CREATE INDEX IF NOT EXISTS idx_model_predictions_model_id ON model_predictions(model_id);
CREATE INDEX IF NOT EXISTS idx_model_predictions_unresolved ON model_predictions(model_id, created_at)
    WHERE resolved_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_model_predictions_created_at ON model_predictions(created_at);

-- T004: Indexes for model_revisions
CREATE INDEX IF NOT EXISTS idx_model_revisions_model_id ON model_revisions(model_id);
CREATE INDEX IF NOT EXISTS idx_model_revisions_trigger_type ON model_revisions(trigger_type);
CREATE INDEX IF NOT EXISTS idx_model_revisions_created_at ON model_revisions(created_at);

-- ============================================================================
-- T005: VIEWS
-- ============================================================================

-- Active models summary with statistics
CREATE OR REPLACE VIEW active_models_summary AS
SELECT
    mm.id,
    mm.name,
    mm.domain,
    mm.prediction_accuracy,
    array_length(mm.constituent_basins, 1) as basin_count,
    mm.revision_count,
    COUNT(mp.id) as total_predictions,
    AVG(mp.prediction_error) FILTER (WHERE mp.resolved_at IS NOT NULL) as avg_error,
    MAX(mp.created_at) as last_prediction
FROM mental_models mm
LEFT JOIN model_predictions mp ON mm.id = mp.model_id
WHERE mm.status = 'active'
GROUP BY mm.id, mm.name, mm.domain, mm.prediction_accuracy, mm.constituent_basins, mm.revision_count;

-- Models needing revision (high error rate in last 7 days)
CREATE OR REPLACE VIEW models_needing_revision AS
SELECT
    mm.id,
    mm.name,
    mm.domain,
    AVG(mp.prediction_error) as recent_avg_error,
    COUNT(mp.id) as recent_predictions
FROM mental_models mm
JOIN model_predictions mp ON mm.id = mp.model_id
WHERE mm.status = 'active'
    AND mp.resolved_at IS NOT NULL
    AND mp.created_at > CURRENT_TIMESTAMP - INTERVAL '7 days'
GROUP BY mm.id, mm.name, mm.domain
HAVING AVG(mp.prediction_error) > 0.5;

-- ============================================================================
-- T006: ALTER active_inference_states
-- ============================================================================

-- Add source_model_id column to link inference states to mental models
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'active_inference_states' AND column_name = 'source_model_id'
    ) THEN
        ALTER TABLE active_inference_states ADD COLUMN source_model_id UUID REFERENCES mental_models(id);
        CREATE INDEX idx_active_inference_states_source_model ON active_inference_states(source_model_id);
    END IF;
END $$;

-- ============================================================================
-- T007: SQL FUNCTION create_mental_model()
-- ============================================================================

CREATE OR REPLACE FUNCTION create_mental_model(
    p_name VARCHAR(255),
    p_domain model_domain,
    p_basin_ids UUID[],
    p_description TEXT DEFAULT NULL,
    p_prediction_templates JSONB[] DEFAULT ARRAY[]::JSONB[]
)
RETURNS UUID
LANGUAGE plpgsql
AS $$
DECLARE
    v_model_id UUID;
    v_invalid_basins UUID[];
BEGIN
    -- Validate that all basin IDs exist in memory_clusters
    SELECT ARRAY_AGG(b) INTO v_invalid_basins
    FROM UNNEST(p_basin_ids) AS b
    WHERE NOT EXISTS (SELECT 1 FROM memory_clusters WHERE id = b);

    IF v_invalid_basins IS NOT NULL AND array_length(v_invalid_basins, 1) > 0 THEN
        RAISE EXCEPTION 'One or more basin IDs do not exist: %', v_invalid_basins;
    END IF;

    -- Create the model
    INSERT INTO mental_models (
        name,
        domain,
        constituent_basins,
        description,
        prediction_templates
    ) VALUES (
        p_name,
        p_domain,
        p_basin_ids,
        p_description,
        p_prediction_templates
    )
    RETURNING id INTO v_model_id;

    RETURN v_model_id;
END;
$$;

-- ============================================================================
-- T008: SQL FUNCTION generate_model_prediction()
-- ============================================================================

CREATE OR REPLACE FUNCTION generate_model_prediction(
    p_model_id UUID,
    p_prediction JSONB,
    p_context JSONB DEFAULT NULL,
    p_confidence FLOAT DEFAULT 0.5,
    p_inference_state_id UUID DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
AS $$
DECLARE
    v_prediction_id UUID;
    v_model_exists BOOLEAN;
BEGIN
    -- Validate model exists and is active
    SELECT EXISTS(
        SELECT 1 FROM mental_models
        WHERE id = p_model_id AND status = 'active'
    ) INTO v_model_exists;

    IF NOT v_model_exists THEN
        RAISE EXCEPTION 'Model not found or not active: %', p_model_id;
    END IF;

    -- Create the prediction
    INSERT INTO model_predictions (
        model_id,
        prediction,
        context,
        confidence,
        inference_state_id
    ) VALUES (
        p_model_id,
        p_prediction,
        p_context,
        p_confidence,
        p_inference_state_id
    )
    RETURNING id INTO v_prediction_id;

    RETURN v_prediction_id;
END;
$$;

-- ============================================================================
-- T009: SQL FUNCTION resolve_prediction()
-- ============================================================================

CREATE OR REPLACE FUNCTION resolve_prediction(
    p_prediction_id UUID,
    p_observation JSONB,
    p_prediction_error FLOAT
)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    v_model_id UUID;
    v_current_accuracy FLOAT;
    v_prediction_count INTEGER;
    v_new_accuracy FLOAT;
BEGIN
    -- Validate prediction exists and is unresolved
    SELECT model_id INTO v_model_id
    FROM model_predictions
    WHERE id = p_prediction_id AND resolved_at IS NULL;

    IF v_model_id IS NULL THEN
        RAISE EXCEPTION 'Prediction not found or already resolved: %', p_prediction_id;
    END IF;

    -- Validate error range
    IF p_prediction_error < 0.0 OR p_prediction_error > 1.0 THEN
        RAISE EXCEPTION 'Prediction error must be between 0.0 and 1.0';
    END IF;

    -- Update the prediction
    UPDATE model_predictions
    SET
        observation = p_observation,
        prediction_error = p_prediction_error,
        resolved_at = CURRENT_TIMESTAMP
    WHERE id = p_prediction_id;

    -- Update model's rolling accuracy (exponential moving average)
    SELECT prediction_accuracy INTO v_current_accuracy
    FROM mental_models WHERE id = v_model_id;

    -- New accuracy = 0.9 * current + 0.1 * (1 - error)
    v_new_accuracy := (0.9 * v_current_accuracy) + (0.1 * (1.0 - p_prediction_error));

    UPDATE mental_models
    SET
        prediction_accuracy = v_new_accuracy,
        last_validated = CURRENT_TIMESTAMP,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = v_model_id;
END;
$$;

-- ============================================================================
-- T010: SQL FUNCTION flag_model_revision()
-- ============================================================================

CREATE OR REPLACE FUNCTION flag_model_revision(
    p_model_id UUID,
    p_trigger_type revision_trigger,
    p_trigger_description TEXT DEFAULT NULL,
    p_trigger_memory_id UUID DEFAULT NULL,
    p_basins_to_add UUID[] DEFAULT NULL,
    p_basins_to_remove UUID[] DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
AS $$
DECLARE
    v_revision_id UUID;
    v_old_structure JSONB;
    v_new_basins UUID[];
    v_current_accuracy FLOAT;
BEGIN
    -- Get current model structure
    SELECT
        jsonb_build_object(
            'constituent_basins', constituent_basins,
            'basin_relationships', basin_relationships,
            'prediction_templates', prediction_templates
        ),
        constituent_basins,
        prediction_accuracy
    INTO v_old_structure, v_new_basins, v_current_accuracy
    FROM mental_models
    WHERE id = p_model_id;

    IF v_old_structure IS NULL THEN
        RAISE EXCEPTION 'Model not found: %', p_model_id;
    END IF;

    -- Calculate new basins
    IF p_basins_to_add IS NOT NULL THEN
        v_new_basins := v_new_basins || p_basins_to_add;
    END IF;

    IF p_basins_to_remove IS NOT NULL THEN
        v_new_basins := ARRAY(
            SELECT unnest(v_new_basins)
            EXCEPT
            SELECT unnest(p_basins_to_remove)
        );
    END IF;

    -- Ensure at least one basin remains
    IF array_length(v_new_basins, 1) IS NULL OR array_length(v_new_basins, 1) < 1 THEN
        RAISE EXCEPTION 'Cannot remove all basins from model';
    END IF;

    -- Create revision record
    INSERT INTO model_revisions (
        model_id,
        trigger_type,
        trigger_description,
        trigger_memory_id,
        old_structure,
        basins_added,
        basins_removed,
        prediction_error_before
    ) VALUES (
        p_model_id,
        p_trigger_type,
        p_trigger_description,
        p_trigger_memory_id,
        v_old_structure,
        COALESCE(p_basins_to_add, ARRAY[]::UUID[]),
        COALESCE(p_basins_to_remove, ARRAY[]::UUID[]),
        1.0 - v_current_accuracy
    )
    RETURNING id INTO v_revision_id;

    -- Update model with new basins
    UPDATE mental_models
    SET
        constituent_basins = v_new_basins,
        revision_count = revision_count + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_model_id;

    -- Update revision with new structure
    UPDATE model_revisions
    SET new_structure = (
        SELECT jsonb_build_object(
            'constituent_basins', constituent_basins,
            'basin_relationships', basin_relationships,
            'prediction_templates', prediction_templates
        )
        FROM mental_models WHERE id = p_model_id
    )
    WHERE id = v_revision_id;

    RETURN v_revision_id;
END;
$$;

-- ============================================================================
-- UPDATE TRIGGER
-- ============================================================================

-- Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION update_mental_models_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS mental_models_updated_at ON mental_models;
CREATE TRIGGER mental_models_updated_at
    BEFORE UPDATE ON mental_models
    FOR EACH ROW
    EXECUTE FUNCTION update_mental_models_updated_at();

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON TABLE mental_models IS 'Mental models combining memory basins for prediction generation (Yufik neuronal packet theory)';
COMMENT ON TABLE model_predictions IS 'Predictions generated by mental models with resolution tracking';
COMMENT ON TABLE model_revisions IS 'Audit trail of mental model structure changes';
COMMENT ON VIEW active_models_summary IS 'Statistics for active mental models';
COMMENT ON VIEW models_needing_revision IS 'Models with >50% average error in last 7 days';
