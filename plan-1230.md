# Implementation Plan: Metacognitive Particles Integration
**Created**: 2025-12-30
**Source**: "Metacognitive particles, mental action and the sense of agency" (Sandved-Smith & Da Costa)
**Branch**: `038-thoughtseeds-framework`

## Overview
This plan integrates concepts from the Metacognitive Particles paper into the Dionysus3 cognitive architecture, prioritized by benefit and feasibility.

---

## Priority 1: Active Metacognition (Critical Gap)

### Current State
- `api/agents/metacognition_agent.py` implements **PASSIVE** metacognition only
- Observes and logs but doesn't modulate lower-level belief parameters
- `self_modeling_callback.py` logs prediction errors but takes no corrective action

### Target State
- Implement **ACTIVE** metacognition: higher-level active paths (a^2) that modulate lower-level beliefs
- Mental actions should adjust precision/attention parameters in lower agents
- Example: When prediction error > threshold, actively increase attention precision

### Files to Modify
- `api/agents/metacognition_agent.py` - Add active modulation capabilities
- `api/agents/self_modeling_callback.py` - Trigger active corrections, not just logging
- `api/services/efe_engine.py` - Add precision-weighted EFE calculations

### Success Criteria
- [ ] MetacognitionAgent can modulate perception/reasoning agent parameters
- [ ] High prediction errors trigger active precision adjustments
- [ ] Measurable reduction in prediction error over time

---

## Priority 2: Formal Nested Markov Blanket Hierarchy

### Current State
- `specs/038-thoughtseeds-framework/02_markov_blankets.md` specifies blanket structure
- ThoughtSeeds have blankets but nesting isn't formally implemented
- No explicit eta/b/mu partition enforcement

### Target State
- Implement N-level nested Markov blankets with proper conditional independence
- Each level: external paths (eta), blanket (b = sensory + active), internal paths (mu)
- Enforce: mu^(n+1) is subset of mu^n (higher-level internal paths are subset of lower-level)

### Files to Create/Modify
- `api/models/markov_blanket.py` - New formal blanket data structure
- `api/services/blanket_enforcement.py` - Conditional independence validation
- Neo4j schema: Add `[:SENSORY]`, `[:ACTIVE]` edge types

### Success Criteria
- [ ] Each ThoughtSeed has validated nested blanket structure
- [ ] Conditional independence automatically enforced
- [ ] 50% reduction in context bleed (per spec SC-002)

---

## Priority 3: Sense of Agency via KL Divergence

### Current State
- No explicit agency detection mechanism
- Cannot distinguish self-generated vs externally-caused state changes

### Target State
- Implement sense of agency as KL divergence: D_KL[p(mu,a) || p(mu)p(a)]
- High KL = strong coupling between internal states and actions = agency
- Zero KL = statistical independence = no agency (mere observation)

### Files to Create
- `api/services/agency_detector.py` - KL-based agency calculation
- Integration with `efe_engine.py` for agency-weighted decisions

### Success Criteria
- [ ] System can detect when actions are self-caused vs externally-driven
- [ ] Agency score influences confidence in action outcomes
- [ ] Logs agency attribution for debugging

---

## Priority 4: Strange Particle Architecture

### Current State
- Standard agent architecture assumes direct influence paths
- No support for indirect inference requirement

### Target State
- Implement "strange particle" constraint: active paths cannot directly influence internal paths
- Higher levels must infer lower-level states via sensory paths only
- Prevents "cheating" where metacognition directly reads lower states

### Files to Modify
- `api/agents/metacognition_agent.py` - Add strange particle constraint
- `api/agents/consciousness_manager.py` - Enforce indirect observation

### Success Criteria
- [ ] Metacognition cannot directly access lower agent internal states
- [ ] All cross-level observation goes through sensory interface
- [ ] Architecture matches biological constraint

---

## Priority 5: Precision-Weighted Belief Updates

### Current State
- Flat belief updates without precision weighting
- `belief_tracking_service.py` uses simple confidence scores

### Target State
- Implement precision (inverse variance) weighting for belief updates
- Higher precision = more confident beliefs = harder to update
- Mental actions can modulate precision (attention allocation)

### Files to Modify
- `api/services/belief_tracking_service.py` - Add precision weighting
- `api/models/cognitive.py` - Add precision field to belief models

### Success Criteria
- [ ] All beliefs have precision/confidence weighting
- [ ] High-precision beliefs resist spurious updates
- [ ] Precision can be modulated by attention

---

## Priority 6: Cognitive Core Protection

### Current State
- No explicit protection for core identity/values
- All beliefs equally modifiable

### Target State
- Implement "cognitive core" (mu^N) - innermost internal states
- Core cannot be target of metacognitive modification
- Maps to `BASAL` priors in existing hierarchy

### Files to Modify
- `api/services/prior_hierarchy.py` - Add core protection
- `api/agents/metacognition_agent.py` - Enforce core immutability

### Success Criteria
- [ ] Core beliefs cannot be modified by metacognition
- [ ] 0 core value violations (per spec SC-003)
- [ ] Clear audit trail for attempted violations

---

## Priority 7: Multi-Level EFE Decomposition

### Current State
- `efe_engine.py` calculates single-level EFE
- No multi-level decomposition

### Target State
- Implement hierarchical EFE: G_total = Sum of G_level
- Each level contributes epistemic + pragmatic components
- Lower levels constrained by higher-level goals

### Files to Modify
- `api/services/efe_engine.py` - Add hierarchical calculation
- `api/services/prior_hierarchy.py` - Provide constraint weights

### Success Criteria
- [ ] EFE calculated across all hierarchy levels
- [ ] Higher levels constrain lower-level exploration
- [ ] Balanced epistemic/pragmatic behavior

---

## Priority 8: Temporal Depth in Policy Selection

### Current State
- Single-step action selection
- No future consequence modeling

### Target State
- Implement expected path integral over future trajectories
- G(pi) = E_pi[Sum_tau G(o_tau, s_tau)]
- Consider consequences N steps ahead

### Files to Create
- `api/services/temporal_policy.py` - Temporal policy selection
- Integration with `consciousness_manager.py` DECIDE phase

### Success Criteria
- [ ] Policy selection considers future consequences
- [ ] Configurable planning horizon
- [ ] Balances immediate vs long-term goals

---

## Priority 9: Explicit Counterfactual Reasoning

### Current State
- No explicit "what if" reasoning
- Cannot model alternative action outcomes

### Target State
- Implement counterfactual simulation for policy evaluation
- "What would happen if I did X instead of Y?"
- Essential for learning from mistakes

### Files to Create
- `api/services/counterfactual.py` - Counterfactual reasoning service
- Integration with learning/model update pipeline

### Success Criteria
- [ ] System can simulate "what if" scenarios
- [ ] Counterfactual regret drives learning
- [ ] Improved action selection over time

---

## Priority 10: Belief-About-Belief Tracking

### Current State
- `belief_tracking_service.py` tracks first-order beliefs only
- No explicit meta-beliefs

### Target State
- Track beliefs about beliefs (meta-beliefs)
- "I believe that my belief about X is accurate/inaccurate"
- Essential for calibrated confidence

### Files to Modify
- `api/services/belief_tracking_service.py` - Add meta-belief layer
- `api/models/cognitive.py` - Add meta-belief models

### Success Criteria
- [ ] System tracks beliefs about its own beliefs
- [ ] Meta-beliefs influence confidence calibration
- [ ] Supports epistemic humility

---

## Dependencies

- Feature 038-thoughtseeds-framework (in progress)
- Neo4j schema updates for blanket edges
- Graphiti integration for knowledge persistence
- n8n webhooks for all Neo4j operations

---

## Notes

### Gap: Attractor Basin Memory Routing (Priority 0 - IDENTIFIED)

**Current State (Dionysus3):**
- Memory types defined in `api/models/sync.py:23-29`: EPISODIC, SEMANTIC, PROCEDURAL, STRATEGIC
- Attractor basins used for **extraction context** in `kg_learning_service.py`:
  - `_get_relevant_basins()` queries basins for guiding extraction
  - `_strengthen_basins()` reinforces basins from extracted entities
  - Hebbian co-activation learning implemented
- `graphiti_service.py:386` accepts `basin_context` parameter

**Missing (vs Dionysus-2.0):**
- **Memory Type Routing**: Different memory types should flow through **specific basin categories**
- No classification of incoming memories into episodic/semantic/procedural/strategic before basin routing
- No basin specialization (e.g., "episodic-basin", "procedural-basin")
- No memory-type-aware strengthening of basins

**Recommended Implementation:**
```python
class MemoryBasinRouter:
    """Route memories through specialized attractor basins by type."""

    BASIN_MAPPING = {
        MemoryType.EPISODIC: "experiential-basin",    # Time-tagged experiences
        MemoryType.SEMANTIC: "conceptual-basin",      # Facts and relationships
        MemoryType.PROCEDURAL: "procedural-basin",    # How-to knowledge
        MemoryType.STRATEGIC: "strategic-basin",      # Planning patterns
    }

    async def route_memory(self, content: str, memory_type: MemoryType):
        basin_name = self.BASIN_MAPPING[memory_type]
        await self._activate_basin(basin_name, content)
        await self._ingest_with_basin_context(content, basin_name)
```

**Files to Create/Modify:**
- `api/services/memory_basin_router.py` - New routing service
- `api/services/kg_learning_service.py` - Add memory type classification
- `api/services/graphiti_service.py` - Add memory_type parameter to ingest methods

### Knowledge Ingestion (COMPLETE)
Paper concepts ingested into Neo4j via:
1. `scripts/ingest_metacognitive_particles_paper.py` (CREATED)
2. Graphiti service (approved Neo4j access)
3. Memory types organized:
   - **Episodic**: Paper sections (9 sections)
   - **Semantic**: Concepts (15) + Relationships (15)
   - **Procedural**: Mathematical formulas (5)
   - **Strategic**: Architecture patterns (5)

---

## Status Tracking

- [ ] Priority 1: Active Metacognition
- [ ] Priority 2: Nested Markov Blankets
- [ ] Priority 3: Sense of Agency
- [ ] Priority 4: Strange Particle
- [ ] Priority 5: Precision Weighting
- [ ] Priority 6: Cognitive Core
- [ ] Priority 7: Hierarchical EFE
- [ ] Priority 8: Temporal Depth
- [ ] Priority 9: Counterfactual Reasoning
- [ ] Priority 10: Meta-Belief Tracking

**Last Updated**: 2025-12-30
